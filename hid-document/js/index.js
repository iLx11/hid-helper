let str = `4.1 Application Usages
Usage Name Usage Type Description
Pointer CP A collection of axes that generates a value to direct, indicate, or point user intentions
to an application.
Mouse CA A hand-held, button-activated input device that when rolled along a flat surface,
directs an indicator to move correspondingly about a computer screen, allowing the
operator to move the indicator freely in select operations or to manipulate text or
graphics. A mouse typically consists of two axes (X and Y) and one, two, or three
buttons.
Joystick CA A manual control or cursor device. A joystick minimally consists of two variable
axes (X and Y) and two buttons. A joystick is typically a rotational motion sensor.
However, for legacy reasons, it is defined using linear axes.
Traditionally, a joystick driver applies its own scaling to values returned
from a joystick. That is, the driver simply linearizes and translates the range of
values generated by the stick into normalized values between 0 and 64K, where
32K is centered. The application (game) then interprets the normalized values as
necessary. Because of this, joysticks normally do not declare Units or Physical
Minimum and Physical Maximum values for their axes. Depending on the
driver, these items may be ignored if they are declared.
Gamepad CA A manual control or cursor device. A game pad minimally consists of a
thumb-activated rocker switch that controls two axes (X and Y) and has four
buttons. The rocker switch consists of four contact closures for up, down, right,
and left.
Keyboard CA The primary computer input device. A Keyboard minimally consists of 103
buttons as defined by the Boot Keyboard definition.
Keypad CA Any keyboard configuration that does not meet the minimum requirements of
the Boot Keyboard. Keypad often refers to a supplementary calculator-style
keyboard.
Multi-axis
Controller
CA An input device used to orient eyepoints and or objects in 3 dimensional space. A
Multi-axis Controller typically consists of six, variable axes (X, Y, Z, Rx, Ry and Rz)
and is used by CAD/digital content creation applications for model manipulation
and visualization in 3D space. The device may incorporate zero or more buttons.
Tablet PC
System
Controls
CA System controls on Tablet PCs. This collection is not intended to contain display or
audio data nor touchscreen input. Appropriate controls might be buttons, wheels, or
simple indicators. This collection is intended to be opened by the operating system
in exclusive mode and is not meant for application developers to open directly.
Water
Cooling
Device
CA A collection of sensors and controls that represents a device using liquid to provide
cooling of a thermal environment. A water cooling device contains at least one
thermal reporting control.
Computer
Chassis
Device
CA A collection of usages that represent data about the condition, state, and controls of
sensors and devices attached to a chassis containing the motherboard and associated
components (e.g., processor, graphics controller, hard drives) of a computing device.
Wireless
Radio
Controls
CA A collection of buttons or switches that enable all-wireless radio communication to
be turned on/off.
Portable
Device
Control
CA A collection of controls on the portable devices, for example, volume controls,
rotation lock, power, camera controls, home button, etc.
36
System
Multi-Axis
Controller
CA A collection of controls that may contain the same controls as listed in Multi-Axis
Controller (Usage 0x08) and/or additional associated controls such as wheels, dials,
buttons etc... for exclusive use of the System.
Spatial
Controller
CA A handheld input device that users move freely through space to provide position
and orientation input.
Assistive
Control
CA A manual control or cursor device. An assistive control device may consist of buttons
or a pointing input control to communicate.
37
4.2 Axis Usages
For X, Y, Z, Rx, Ry, and Rz, the declaration of Units is optional. If Units is None or not declared, these values should
be considered as dimensionless.
Usage Name Usage Type Description
X DV A linear translation in the X direction. Report values should increase as the control’s
position is moved from left to right.
Y DV A linear translation in the Y direction. Report values should increase as the control’s
position is moved from far to near.
Z DV A linear translation in the Z direction. Report values should increase as the control’s
position is moved from high to low (Z).
Rx DV A rotation about the X axis. Angular position report values follow the righthand
rule.
Ry DV A rotation about the Y axis. Angular position report values follow the righthand
rule.
Rz DV A rotation about the Z axis. Angular position report values follow the righthand
rule.
38
4.3 Miscellaneous Controls
Usage Name Usage Type Description
Slider DV A linear control for generating a variable value, normally in the form of a thumb
slide in a slot. Report values should increase as controls are moved from near to
far.
Dial DV A rotary control for generating a variable value, normally in the form of a knob
spun by the index finger and thumb. Report values should increase as controls are
spun clockwise. This usage does not follow the HID orientation conventions.
Wheel DV A rotary control for generating a variable value, normally rolled, unlike a dial.
Report values should increase as controls are rolled forward, away from the user.
This usage does not follow the HID orientation conventions.
Hat Switch DV A specialized mechanical configuration of switches generating a variable value with a
NULL state. The switches are arranged around a springloaded knob. When the knob
is tilted in the direction of a switch, its contacts are closed. A typical example is four
switches that are capable of generating information about four possible directions
in which the knob can be tilted. Intermediate positions can also be decoded if the
hardware allows two switches to be reported simultaneously.
Motion Wakeup DF Enables the generation of a USB remote wakeup when the device detects motion.
Motion Wakeup is always enabled after a USB Reset event is detected by the
device. Then host can also assume that the state of the Motion Wakeup flag is
maintained while the device is suspended.
For example, a mouse may generate a remote wakeup when a button is pressed or
when it is moved. For some implementations, a laptop user may want to disable
the wakeup on motion because it draws more power.
Start OOC Session start button. Initiates a session within an application.
Select OOC Application option select button. Selects application configuration options.
Resolution
Multiplier
DV Defines a Resolution Multiplier for a Control.
39
4.3.1 Resolution Multiplier
A HID describes the resolution of a control by using the methods described in the HID Specification, v1.11, section 6.2.2.7
Global Items – Remarks. However, the resolution of a control in this model is static. If a device has the capability to
vary the resolution of one or more of its controls, the resolution of those controls can be set by defining an associated
Resolution Multiplier control.
The Resolution Multiplier control must be contained in the same Logical Collection as the control(s) to which it is to be
applied. If no Resolution Multiplier is defined, then the Resolution Multiplier defaults to 1. If more than one control exists
in a Logical Collection, the Resolution Multiplier is associated with all controls in the collection. If no Logical Collection
is defined, the Resolution Multiplier is associated with all controls in the report.
The Resolution Multiplier is applied after all the normal resolution calculations have been performed for an affected
control. The Resolution Multiplier is calculated as below:
EffectiveResolutionMultiplier =
 RMV − LMin
LMax − LMin
× (PMax − PMin)

+ PMin
× 10UnitExponent
Variable Description
RMV Resolution Multiplier Value
LMin Logical Minimum
LMax Logical Maximum
PMin Physical Minimum
PMax Physical Maximum
For example, if a Wheel Control is defined as below:
Usage Page (Generic Desktop) (0x01)
Usage (Wheel) (0x38)
Logical Minimum (-127)
Logical Maximum (127)
Report Count (1)
Report Size (8)
Input (Data, Var, Rel)
Then, the Wheel control delivers one count per detent via a 1-byte field of an Input Report. However if a Resolution
Multiplier feature is included in the report with the Wheel as below:
Collection (Logical)
Usage Page (Generic Desktop) (0x01)
Usage (Resolution Multiplier) (0x48)
Logical Minimum (0)
Logical Maximum (15)
Physical Minimum (1)
Physical Maximum (16)
Report Size (4)
Report Count (1)
Feature (Data, Var, Abs)
Usage Page (Generic Desktop) (0x01)
Usage (Wheel) (0x38)
Logical Minimum (-127)
Logical Maximum (127)
Report Count (1)
Report Size (8)
Input (Data, Var, Rel)
End Collection
40
Then, the Effective Resolution Multiplier for the Wheel may vary from 1 to 16 depending on the setting of the Resolution
Multiplier feature. If the Resolution Multiplier feature is set to 7, then the Effective Resolution Multiplier is 8, meaning
that the resolution of the Wheel control is 8 counts per detent.
Negative Effective Resolution Multipliers may be used to reverse the sense of a control.
Because OS implementations will generally divide the control’s reported count by the Effective Resolution Multiplier,
designers should take care not to establish a potential Effective Resolution Multiplier of zero. This may be done by
ensuring that Physical Min and Physical Max are nonzero and have the same sign.
The Resolution Multiplier is a scalar (unitless) multiplier. It may not be used to convert units from one system to another.
41
4.4 Vector Usages
For the usages Vx, Vy, Vz, Vbrx, Vbry, Vbrz, and Vno, Units are always required to determine the meaning of the vector.
Rotational vectors are also identified by Units. These usages are used when declaring velocity, acceleration, force, electric
field, and similar kinds of vectors in the respective direction and frame of reference.
Usage Name Usage Type Description
Vx DV A vector in the X direction. Report values should increase as the vector increases
in the positive X direction (from left to right). Negative values represent vectors in
the negative X direction.
Vy DV A vector in the Y direction. Report values should increase as the vector increases
in the positive Y direction (from far to near). Negative values represent vectors in
the negative Y direction.
Vz DV A vector in the Z direction. Report values should increase as the vector increases
in the positive Z direction (from high to low). Negative values represent vectors in
the negative Z direction.
Vbrx DV A vector in the X direction relative to the body of an object. Report values should
increase as the vector increases in the positive X direction (forward). Negative
values represent vectors in the negative X direction. X is the forward axis for an
object.
Vbry DV A vector in the Y direction relative to the body of an object. Report values should
increase as the vector increases in the positive Y direction (to the right from an
observer facing forward on the object). Negative values represent vectors in the
negative Y direction.
Vbrz DV A vector in the Z direction relative to the body of an object. Report values should
increase as the vector increases in the positive Z direction (down from an observer
facing forward on the object). Negative values represent vectors in the negative Z
direction.
Vno DV A non oriented vector or value. The units define a physical measurement not related
to a specific axis or orientation. An example would be pressure or temperature.
42
4.5 System Controls
System controls are a special category of usages that affect the system as a whole. They are pulled together in a System
Control collection to make them easy for system software to identify.
Usage Name Usage Type Description
System Control CA A application-level collection that contains system-software-specific usages.
System software will search specifically for this collection for those controls
that affect the system globally.
System Context Menu OSC Evokes a context-sensitive menu.
System Main Menu OSC Evokes the OS main-level selection menu.
System App Menu OSC Displays an application-specific menu.
System Menu Help OSC Displays the help menu.
System Menu Exit OSC Exits a menu.
System Menu Select OSC Selects a menu item.
System Menu Right RTC Menu select right.
System Menu Left RTC Menu select left.
System Menu Up RTC Menu select up.
System Menu Down RTC Menu select down.
System Function Shift MC Indicates the state of the feature. 1=on, 0=off. Usually this maps directly
to the state of the Fn key, but may be reversed if the System Function Shift
Lock is also on.
System Function Shift
Lock
OOC Locks the System Function Shift state. This is an On/Off control with
a recommended implementation of Relative, Preferred State for physically
non-locking keys, and Absolute, No Preferred state for physically locking
keys.
System Function Shift
Lock Indicator
DV The value of a visual indicator of System Function Shift Lock.
System Dismiss
Notification
OSC Dismisses active notification (e.g. pop-ups/alerts) from system environments
and applications that arrest the user’s attention (e.g. Voice Assistants, VOIP
calls, Alarms). Many modern devices have a paradigm of dismissing such
notifications using the Power button.
System Do Not
Disturb
OOC Toggle system-wide Do Not Disturb (DND) mode On/Off.
System Dock OSC Asserted when the intended action is to prepare a portable system for docking
with a docking station.
System Undock OSC Asserted when the intended action is to prepare a portable system for removal
from a docking station.
System Setup OSC Asserted when the intended action is to enter the BIOS-level system setup
program.
System Speaker Mute OSC Asserted when the intended action is to mute the system speaker.
System Hibernate OSC Asserted when the intended action is to place the system in a "deeper" sleep
state than System Sleep
43
System Microphone
Mute
OOC Toggle system-wide ‘microphone mute’ state On/Off. (e.g. if system
‘microphone mute’ state is unmute, toggle it to mute, and vice-versa).
Asserting this Usage indicates to turn-off/disable/mute all microphones at
system level (and-vice-versa). The system maintains a global ‘microphone
mute state which affects microphones connected internally and externally.
Note: The device cannot derive the current system ‘microphone mute’ state
from the lack-of or previous assertion of this Usage or any other Usage. (as
the system ‘microphone mute’ state may have been set by a user via system
UI, or another device).
Note: This conceptually ‘overrides’ the ‘Call Mute Toggle’ state, as a ‘Call’
may not be muted, but all system microphones being muted has a similar
affect.
4.5.1 Power Controls
Power controls can step the system through the following states: Full Power, Low Power, and Power Down. Power control
usages found in a System Control collection affect system level power. Those declared outside of a System Collection
affect device level power.
Usage Name Usage Type Description
System Power Down OSC Asserted when the intended action is to initiate system-wide power down now
from Full Power or Sleep states.
System Sleep OSC Asserted when the intended action is to initiate system-wide low power mode
now. If the system is already in the Low Power state, there is no effect.
System Wake Up OSC Asserted when the intended action is to initiate system-wide Full Power state
now. If the system is already in the Full Power, there is no effect.
System Cold Restart OSC Asserted when the intended action is to restart the system at the most
primitive level, similar to at Power Up.
System Warm Restart OSC Asserted when the intended action is to restart the operating system but not
necessarily the lowest level functions such as BIOS enumeration and RAM
checks.
44
Full
Power
Low
Power
Power
Down
System Sleep
System Power Down
System Wake Up
Figure 4.1: System Power States
45
4.6 Buffered Bytes
The following usages provide a standard way of defining the operation of a buffered-byte field where the number of valid
bytes in the field is less than the total number of bytes in the field and the vendor does no define a NoOp value to mark
unused bytes.
When declaring a buffered-byte field, the global item Report Size should always be set to 8 (for byte cells), and the
Report Count should be equal to the maximum size of the buffer to be transferred.
Usage Name Usage Type Description
Counted
Buffer
CL Used with buffered–byte data to indicate the number of valid bytes in the
buffered-byte field. This collection always contains two field declarations: Byte
Count and a usage that names the purpose of the buffered-byte field. The Main
item associated with the purpose usage will always have the Buffered Bytes attribute
set.
Byte Count DV Defines a report field that indicates the number of meaningful data bytes in an
associated buffered-byte field.
46
4.7 Direction Pads
A Direction Pad or D-Pad control is mechanically identical to a hatswitch, however for legacy reasons their data is
interpreted as X and Y axes rather than as an angular direction.
D-pads are typically defined as a pair of X and Y axes that are contained in a logical Pointer collection. There are cases
where an application may be interested in the raw D-pad data. The following usages are defined in a report descriptor as
single bit fields that identify the current state of the position switches in the D-pad.
Note: A device may declare a Pointer collection with X and Y axes, and D-pad usages for the same control.
An application can determine which data format best suits it’s needs.
Usage Name Usage Type Description
D-pad Up OOC Indicates that top of a Direction Pad is pressed.
D-pad Down OOC Indicates that bottom of a Direction Pad is pressed.
D-pad Right OOC Indicates that right side of a Direction Pad is pressed.
D-pad Left OOC Indicates that left side of a Direction Pad is pressed.
47
4.8 Feature Notifications
It may be useful to alert the host that the contents of a Feature report have changed without redundantly declaring a usage
in an Input report, especially is the changes are only occasional. The Feature Notification usages provides a mechanism
for doing this.
Usage Name Usage Type Description
Feature
Notification
DV This usage is declared in an Input report and is used as a notification to the host
that the contents of a specific Feature report has changed.
If Report IDs are declared in the device’s report descriptor then the Report Size
of the Feature Notification must be greater than 1, and the Feature Notification
field contains the Report ID of the Feature report that whose contents have
changed. A zero value indicates that no Feature reports have changed. Multiple
Feature report IDs can be reported in a single Input report by declaring the
Report Count to be greater than 1.
If Report IDs are not declared in the device’s report descriptor then the
Report Size of the Feature Notification equals 1, and the Input report field equals
1 if the Feature report contents have changed. A zero value indicates that no
Feature reports have changed.
When a valid Feature Notification is received, the host must issue a
GetReport(Feature) request to the device with the appropriate report ID.
48
4.9 Software Flow Controls
The following usages provide standard controls to break into the current operation of the system.
Usage Name Usage Type Description
System Break OSC Asserted when the intended action is to acquire the attention of the operating
system in order to control applications. This operation could interrupt all running
applications.
System
Debugger Break
OSC Asserted when the intended action is to break into the operating system debugger.
If no OS debugger is running, the control is ignored.
Application
Break
OSC Asserted when the intended action is to acquire the attention of an application.
This operation interrupts only the foremost running application.
Application
Debugger Break
OSC Asserted when the intended action is to break into the application debugger. If no
application debugger is running, the control is ignored.
49
4.10 System Display Controls
Many systems currently support multiple displays. Of special note are portable systems with captive displays that may
be connected to external displays. The following usages provide standard controls for common display control functions:
Usage Name Usage Type Description
System Display Invert OSC Causes the display to render in inverted colors.
System Display Internal OSC Causes the system to use the captive display as the primary display.
System Display External OSC Causes the system to use the external display as the primary display.
System Display Both OSC Causes the system to use both internal and external displays as the
primary display.
System Display Dual OSC Causes the system to use both internal and external displays as primary
and secondary displays.
System Display Toggle
Int/Ext Mode
OSC Causes a system to step between the modes as described above:
• System Display Internal
• System Display External
• System Display Both
System Display Swap
Primary/Secondary
OSC Causes a system using two displays in dual mode to swap the primary
and secondary displays.
System Display Toggle
LCD Autoscale
OSC Causes a system with a non-scaleable geometry, such as an LCD, to scale
the display image to fit the physical geometry of the display.
System Display Rotation
Lock Button
OOC Indicates the current state of a system display rotation lock on/off
momentary push button. State must be reported once for every button
press.
System Display Rotation
Lock Slider Switch
OOC Indicates the absolute value for the state of system display rotation lock.
State must be reported when it goes from 0 to 1 as well as from 1 to 0.
50
4.11 Computer Sensor Controls
Advances in the enthusiast class personal computer has led to the development of intelligent water cooling devices,
chassis, and power supplies that provide addition status, monitoring, and control information to the user on the health
and capabilities of their system. In addition to the raw sensor data, the sensors can be grouped into logical thermal
and control zones to represent different operating areas within the device (e.g., thermal zones around the processor, hard
drives, or PCI-E slots).
Usage Name Usage Type Description
Sensor Zone CL A logical collection that represents a grouping of sensors or other controls
within a device that control a common physical region or physical function
within the device when one or more physical regions exist.
RPM DV Indicates or controls the current revolutions per minute of a rotating device
(e.g., fan). This usage shall be represented as units of rotations per minute.
Coolant Level DV Indicates the current level of coolant in its coolant containment container.
This usage shall be represented as a percentage with a logical minimum of
zero and a logical maximum of 100.
Coolant Critical Level SV Indicates the level at which the coolant is below a critical threshold at which
the potential for damage exists.
Coolant Pump US This collection allows the usages that it contains to be associated with a
coolant pump. In this collection one or more RPM usages are found.
Chassis Enclosure CL This collection represents the dimensions of a computer chassis. This
collection shall contain an X, Y, and Z usage.
51
4.12 Wireless Radio Controls
Usage Name Usage Type Description
Wireless Radio Button OOC Indicates the current state of a wireless on/off momentary push button. State
must be reported once for every button press.
Wireless Radio LED OOC Indicates the current state of wireless communication to the user. This will
reflect the state of the overall system radio state.
Wireless Radio Slider
Switch
OOC Indicates the absolute value for the state of radio communications. State
must be reported when it goes from 0 to 1 as well as 1 to 0.
52
4.13 Generic Controls
Usage Name Usage Type Description
Control Enable DF Enable or disable the controls within the current logical collection. A value
of 1 indicates that the controls in the same logical collection are enabled. A
value 0 indicates they are disabled.
When disabled, controls that are declared without the NULL attribute
will keep their last values. Controls that declare the NULL attribute will be
in a NULL state without further state changes. Also, such controls that are
not in NULL that get disabled will move to NULL and input controls should
generate a report to that effect. Feature and output reports will change
silently.
53
4.14 Spatial Controls
A spatial controller is a handheld input device that users move freely through space to provide position and orientation
input. The spatial controller’s orientation is represented as a rotation relative to its neutral orientation. The neutral
orientation is the controller’s orientation when sitting flat on a surface pointing forward along the negative Y axis, with
gravity pointing down along the positive Z axis and with X increasing from the Controller’s left to its right. The forward
direction in the XY plane is unspecified and implementation-specific. This rotation is expressed as a unit quaternion
(Qx/Qy/Qz/Qw).
If the Spatial Controller reports position in addition to orientation, the translation axes must correspond to the rotation
axes.
Note: Expressing a rotation as a quaternion avoids ambiguity about the order in which the host must apply
the three axis rotations. Many applications also choose to use quaternions instead of Euler angles in their
own logic to avoid gimbal lock. Surfacing quaternions directly to such apps from the device’s firmware reduces
precision loss caused by the conversion from Rx/Ry/Rz.
Usage Name Usage Type Description
Qx DV The X component of a unit quaternion, representing a rotation in space about a
unit vector. Rotations represented by quaternion report values follow the right-hand
rule.
Qy DV The Y component of a unit quaternion, representing a rotation in space about a
unit vector. Rotations represented by quaternion report values follow the right-hand
rule.
Qz DV The Z component of a unit quaternion, representing a rotation in space about a unit
vector. Rotations represented by quaternion report values follow the right-hand
rule.
Qw DV The W component of a unit quaternion, representing a rotation in space about a
unit vector. Rotations represented by quaternion report values follow the right-hand
rule.
Index Trigger MC/DV The pressure applied to an input device’s index-finger trigger, indicating that the
user is pulling their index finger. This usage can be a DV for an analog trigger or
an MC for a digital trigger.
Palm Trigger MC/DV The pressure applied to an input device’s palm trigger, indicating that the user is
closing their fist tightly around the controller. This usage can be a DV for an analog
trigger or an MC for a digital trigger.
Thumbstick CP An input device’s two-axis thumb-operated control stick. The thumbstick’s X value
increases from left to right and its Y value increases from bottom to top. A
thumbstick is typically a rotational motion sensor. However, for legacy reasons,
it is defined using linear axes.
54
Z+
X+
Y+
Up
Forward
Right
Gravity
Figure 4.2: Spatial Controller Orientation
55
4.15 Dockable Devices
In many computing systems, there are cases where a potentially non-HID Dockable Devices can be physically attached
to a system or another device - whether for storage, to charge, or for ergonomic usage of the device relative to the needs of
the computing system. While modern operating systems may be able to detect some elements of this attachment though
device enumeration or ACPI information, there are use cases where rich information specific to the state of the Dockable
Device’s attachment to the system can be valuable.
For example, a digital pen which only communicates with a digitizer within a short range may not be able to communicate
that it has been attached to a pen holder on the device for the system to update UI showing the pen has been connected.
Other representations may disable a Dockable Device’s connection to the host when placed in a dock to allow for
reduced power consumption.
In other cases, the Device Dock itself may have access to information that the Dockable Device may not. In a system
with a horizontal display, for example, it may be possible for a sensor to detect exactly where a Dockable Device or
other object has been placed relative to the display, so that the system may adjust placement of UI around it, while the
object itself is incapable of detecting or reporting this information.
Usage Name Usage Type Description
Device Dock CA A device that reports the presence of a Dockable Device physically attached
to the system.
Dockable Device CA A device describing a Dockable Device that can be physically attached to
the system.
Dockable Device
Unique ID
DV Specifies the unique ID identifying the device which has been docked.
This is an optional Usage - if the Dockable Device does not have
a Dockable Device Unique ID or the Device Dock is not capable of
reading the Dockable Device Unique ID from the device, this would
not be provided. If provided, the Dockable Device Unique ID must be
unique for the USB-IF VendorId, specified by Dockable Device Vendor
ID below. For example, this could contain the unique serial number of
the Dockable Device or a product identifier if a serial number cannot be
provided.
Dockable Device
Vendor ID
DV Specifies the USB-IF VendorId of the Dockable Device, used in combination
with Dockable Device Unique ID to uniquely identify the device.
This is an optional Usage. If provided, this must be a 16-bit value.
Dockable Device
Primary Usage Page
DV Specifies the UsagePage of the primary top-level collection of the Dockable
Device (in the case of a complex HID device), to allow the system to
understand which Dockable Device has been docked.
This is an optional Usage which can be useful in cases where the
Dockable Device is not connected to the system, or is not capable of
reporting a unique serial number, in conjunction with Dockable Device
Primary Usage ID. For a Dockable Device with multiple HID top-level
collections, the value of this Usage is defined by the vendor.
Dockable Device
Primary Usage ID
DV Specifies the UsageId of the primary top-level collection of the Dockable
Device (in the case of a complex HID device).
This is an optional Usage, used in conjunction with Dockable Device
Primary Usage Page. For a Dockable Device with multiple HID
top-level collections, the value of this Usage is defined by the vendor.
56
Dockable Device
Docking State
DF A bit that indicates if the Dockable Device is currently attached to the
system.
This is a required Usage. A report with this bit set would indicate
the Dockable Device is physically attached to the system. A report with
this bit cleared would indicate the Dockable Device has been physically
detached from the system.
Dockable Device
Display Occlusion
CL A physical collection describing what portion of a display is occluded by the
Device Dock.
This collection is optional – it would not be reported if the supported
Dockable Device cannot occlude the display. This collection could
include values like X, Y, Width (in mm), Height (in mm), Azimuth, etc.
for rectangular-shaped occlusions. Future Usages could support other
Dockable Device shapes.
Dockable Device
Object Type
DV An enum which specifies the type of object which is being docked.
This is an optional usage. It is possible that there could be multiple
Dockable Objects placed relative to the display that also include different
objects types such as:
• 0: Unspecified.
• 1: HID Device.
• 2: Display.
• 3: NFC Device.
57
4.16 Call State Management Control
System environments can offer rich integration of voice/video conferencing applications within the Shell and system-wide
management of ‘calls’ by having a single system-wide ‘call’ state. This state can then be modified via a native Shell
experience or through a brokered device (‘Call State Management Control’). Such a device could be standalone or even
integrated into keyboards as are some system-control devices today (e.g. for power/sleep). ‘Call Mute’, is NOT intended
to be a replacement for existing functionality on existing Audio/Telephony headsets. It is NOT expected, for ‘Call State
Management Control’ devices to be combined/integrated with Telephony Devices or Audio Input devices.
Unlike existing Telephony controls (which reflect the state of a specific audio device, (e.g. headset/speakerphone) associated
with the controls) the below are for system consumption, and is up to the system to decide how best reflect the ‘call’ state
across devices affected by a ‘call’ (e.g. Telephony headset, generic standalone microphone, webcam, non-HIDs, etc...).
Naturally, if there are multiple devices with these Usages, the system will be responsible for deciding how to broker and
maintain state across devices (e.g. similar to a Keyboard’s CapsLock LED).
Usage Name Usage Type Description
Call State
Management
Control
CA System controls for managing the state of the (single) system ‘call’.
Call Active
LED
OOC Asserted by System to indicate there is a currently active system ‘call’.
Level Triggered.
Note: The device must never depend on this value for internal state management
other than LED state (i.e. display only). Do NOT tie this state to ‘Call Mute
Toggle’ or any other device state (e.g. audio). Doing so will create issues with
system management of the device and system ‘call’ mute state.
Call Mute
Toggle
OSC Toggles the system’s ‘call’ mute state, indicating to the system it must change its
current ‘call’ mute state. (e.g. if system ‘call’ mute state is unmute, toggle it to
mute, and vice-versa).
Asserting this Usage does not indicate to turn-off/disable/mute system
microphones (or-vice-versa). Rather, assertion indicates to the system that
audio input should/should-not be rendered on the active ‘call’. (e.g. background
noise-cancelling algorithms in voice-conferencing applications can always access
and process audio input.)
Note: The device cannot derive the current system ‘call’ mute state from the
lack-of or previous assertion of this Usage or any other Usage. (as system ‘call’
mute state may have been set by a user via system/app UI, or another device).
Call Mute LED OOC Asserted by System to indicate the system’s ‘call’ mute state is muted.
Level Triggered.
Note: The device must never depend on this value for internal state management
other than LED state (i.e. display only). Do NOT tie this state to ‘Call Mute
Toggle’ or any other device state (e.g. audio). Doing so will create issues with
system management of the device and system ‘call’ mute state.`

const decodeUsagePage = () => {
  let usesage_page = []
  let strExp = /(\s\d+$)/gi

  /*let strExp = /(\s\d+$)/gi
  let page_id_exp = /^\S+\s/gi
  let page_name_exp = /\s(?<=^\S+\s).+/gi*/

  let page_id_exp = /(?<=^\S+)\s.+/gi
  let page_name_exp = /(?<=^\S+\s)(.+)(?= (OSC\/DF|DV\/DF|DVMC\/DV|MC\/DV|OSC|CP|CA|DL|DF|DV|SV|US|CL|RTC|OOC|Sel|NAry|See\sNote|UM|MC|RTC))/gi
  let page_tyeps_exp = /(OSC\/DF|DV\/DF|DVMC\/DV|MC\/DV|OSC|CP|CA|DL|DF|DV|SV|US|CL|RTC|OOC|Sel|NAry|See\sNote|UM|MC|RTC)/g
  str.split(/\n/g).forEach(o => {
    if (/\s/gi.test(o))
      usesage_page.push({
        'Usage_ID': o.replace(strExp, '').replace(page_id_exp, ''),
        'Usage_Name': o.replace(strExp, '').match(page_name_exp) == null ? 'Reserved' : o.replace(strExp, '').match(page_name_exp)[0],
        'Usage_Types': o.replace(strExp, '').match(page_tyeps_exp) == null ? 'Undefined' : o.replace(strExp, '').match(page_tyeps_exp)[0]
      })
  })
  console.log(JSON.stringify(usesage_page))
  console.log(usesage_page)
}

const decodeUsageString = () => {
  let final = {}
  let page_tyeps_exp = /(OSC\/DF|DV\/DF|DVMC\/DV|MC\/DV|OSC|CP|CA|DL|DF|DV|SV|US|CL|RTC|OOC|Sel|NAry|See\sNote|UM|MC|RTC)/g
  let page_title_exp = /(\d{1}.\d{1,2}\s)|(\d{1}.\d{1,2}.\d{1,2}\s)/g
  let tempObj = ''
  let branch = ''
  let tempStr = ''
  str.split(/Usage Name Usage Type Description/gim).forEach((o, i) => {
    o.split(page_tyeps_exp).forEach(x => {
      if (page_title_exp.test(x)) {
        x.split(/\n/g).forEach(k => {

          if (k.match(/^(\d{1,2}.\d{1,2}\s).+/g) != null) {
            tempObj = k.match(/^(\d{1,2}.\d{1,2}\s).+/g)[0].replace(page_title_exp, '').replace(/\s/g, '_').replace(/^\d/, '')
            branch = ''
          }
          if (k.match(/^(\d{1,2}.\d{1,2}.\d{1,2}\s).+/g) != null) {
            branch = k.match(/^(\d{1,2}.\d{1,2}.\d{1,2}\s).+/g)[0].replace(page_title_exp, '').replace(/\s/g, '_').replace(/^\d/, '')
          }
        })
        if (final[tempObj] == null) final[tempObj] = []
        if (branch != '' && final[tempObj][branch] == null) final[tempObj][branch] = []
      } else {
        x.split(/\n/g).forEach(k => {
          k = k.replace(/\s$/g, '')
          if (k.length < 35 && /^[A-Z]/g.test(k) && !/\.$/g.test(k)) {
            if (branch != '') {
            	if (!page_tyeps_exp.test(k)) {
                tempStr += k
                tempStr += '/'
              } else {
                tempStr = tempStr.replace(/\/$/g, '')
                final[tempObj][branch].push({ 'Usage_Name': tempStr, 'Usage_type': k })
                tempStr = ''
              }
              // branch = ''
            } else {
              if (!page_tyeps_exp.test(k)) {
                tempStr += k
                tempStr += '/'
              } else {
                tempStr = tempStr.replace(/\/$/g, '')
                final[tempObj].push({ 'Usage_Name': tempStr, 'Usage_type': k })
                tempStr = ''
              }

            }
          }
        })

      }
    })
  })
  console.log(final)
  console.log(JSON.stringify(final))
}

// decodeUsagePage()
// decodeUsageString()

let string = {
	'a': [{'b': 'bbbbb'}, 'c': [{'d': 'ddddd'}],
}
console.log(string)
console.log(JSON.parse(string))